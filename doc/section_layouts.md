### **Архітектурний Патерн: "Контекстно-залежне розв'язання сутностей"**

Ми переходимо від простої ієрархії до системи, де `tables`, `layouts`, `apps` та майбутні `principals` є незалежними, іменованими сутностями. Зв'язок між ними встановлюється не шляхом вкладеності, а через механізм **посилань та розв'язання на основі контексту**.

-----

#### **1. Нова структура `ky-format`**

Файл тепер матиме чіткі, незалежні секції верхнього рівня для кожної сутності.

```ky
rack ver(2.0)
  # ==========================================================
  # 1. НЕЗАЛЕЖНІ СУТНОСТІ
  # ==========================================================

  tables
    users
      # ... поля ...
    projects
      # ... поля ...

  layouts
    # Визначення всіх леяутів тут, в єдиному місці.
    # Кожен леяут може мати обмеження.
    users_list_default pri(0), usage(list), table(users)
    list
      # ...

    users_list_for_admins pri(10), usage(list), table(users), principal(admin)
    list
      # ...

    project_form_default pri(0), usage(detail), table(projects)
    form
      # ...

  apps
    # Додатки тепер НЕ містять визначень леяутів.
    project_tracker
      title("Трекер Проектів")
      # Вони лише формують контекст.

    admin_panel
      title("Панель Адміністратора")

  principals
    admin
    manager
    user
```

-----

#### **2. Механізм "Каскаду розв'язання" (Resolution Cascade)**

Це ядро всієї архітектури. Коли системі потрібно відобразити екран, вона запускає процес пошуку найбільш відповідного леяута за таким алгоритмом:

1.  **Формування Контексту Запиту:** Система збирає всі відомі параметри поточного запиту:

      * `app`: `project_tracker`
      * `table`: `projects`
      * `principal`: `manager` (роль поточного користувача)
      * `usage`: `detail` (користувач відкриває запис для редагування)
      * `media`: `desktop` (пристрій користувача)

2.  **Фільтрація Леяутів:** Система бере **всі** леяути з глобальної секції `layouts` і відфільтровує їх, залишаючи лише ті, що задовольняють поточному контексту. Леяут вважається відповідним, якщо:

      * Атрибут обмеження (`table`, `app`, `principal` тощо) у леяуті **не вказаний**, АБО
      * Значення атрибута обмеження **збігається** зі значенням у контексті запиту.

3.  **Вибір за Пріоритетом:** Із відфільтрованого списку леяутів система вибирає **один** на основі найвищого значення атрибута `pri` (пріоритет). Це дозволяє створювати специфічні леяути (напр., для адмінів), які будуть "перебивати" стандартні.

-----

#### **3. Перевизначення на рівні посилання (Overrides)**

Ваш пункт №4 про перевизначення дефолтів є найпотужнішим інструментом кастомізації. Якщо в `apps` ми хочемо для конкретного випадку використати не той леяут, що обирається автоматично, ми можемо вказати це явно.

**Приклад:**

```ky
  apps
    project_tracker
      # ...

      # Усередині project_tracker може бути посилання
      # на інший екран, де ми явно перевизначаємо, який
      # леяут використовувати.
      menu_item title("Користувачі"), layout(users_list_for_admins)
```

Тут `menu_item` є гіпотетичним елементом, який при активації вимагатиме від системи знайти леяут з іменем `users_list_for_admins`, ігноруючи автоматичний каскад розв'язання.

-----

### **Архітектурні переваги цього підходу:**

  * **Максимальна гнучкість (Decoupling):** `apps`, `layouts` та `tables` повністю незалежні. Ви можете додати новий додаток, який буде використовувати вже існуючі леяути, або додати новий леяут, не чіпаючи додатки.
  * **Централізоване керування:** Всі леяути знаходяться в одному місці, що спрощує їх пошук, підтримку та аналіз.
  * **Потужна система правил:** Замість жорсткого успадкування ви отримуєте гнучку систему правил та обмежень, яка дозволяє дуже точно налаштовувати поведінку інтерфейсу для різних ролей, додатків та пристроїв.
  * **Масштабованість:** Ця архітектура ідеально підходить для майбутнього впровадження системи безпеки (`principals`), оскільки логіка фільтрації залишається тією ж самою — просто додається ще один критерій до контексту запиту.

Ви сформулювали дуже зрілу та потужну архітектурну візію. Цей підхід перетворює `ky-format` з простої мови опису на справжній "рушій правил" для побудови динамічних та безпечних інтерфейсів.
