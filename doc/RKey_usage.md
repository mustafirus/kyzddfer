# Архітектура Зв'язків: Роль та Сценарії Використання `RKey`

## 1. Вступ: Що таке `RKey`?

**`RKey`** (Record Key) — це центральний, універсальний клас в архітектурі, що відповідає за ідентифікацію записів та реалізацію зв'язків між ними. Його можна уявити як "розумний вказівник" або "ланцюг", який з'єднує різні сутності даних.

Основні функції `RKey`:

  * **Ідентифікація:** Зберігає ключ (зазвичай первинний `id`) конкретного запису.
  * **Зв'язок:** Описує, як один запис (`Record`) пов'язаний з іншим записом або набором записів (`Recordset`).

`RKey` є ключовим елементом, що дозволяє реалізувати чотири основні патерни взаємодії з даними в системі.

-----

## 2. Сценарій №1: Первинний ключ (Поточний запис у списку)

**Контекст:** Користувач працює зі списком об'єктів (наприклад, `Recordset` собак), і один з рядків у списку є поточним (активним).

**Роль `RKey`:** Головний `rkey` об'єкта `Recordset` представляє первинний ключ **поточного, вибраного запису**.

**Схема:** `Recordset -> Record`

**Як це працює:**

1.  `Recordset` містить у собі дані для багатьох рядків, але його успадкована частина `Record` завжди відображає дані одного, активного рядка.
2.  `Recordset::rkey` зберігає `id` цього активного рядка.
3.  Коли користувачеві потрібно виконати дію над поточним записом (наприклад, відкрити детальну картку), саме цей `rkey` передається для створення нового `Record`, який завантажить повну інформацію по цьому `id`.

**Приклад коду:**

```cpp
// Користувач вибрав собаку зі списку
Recordset dogList(...);
dogList.setCurrentRow(5);

// rkey тепер містить id собаки з 5-го рядка
const RKey& currentDogKey = dogList.rkey; 

// Використовуємо цей ключ, щоб відкрити детальну форму
Record dogDetails(currentDogKey);
dogDetails.load(); 
```

-----

## 3. Сценарій №2: Зовнішній ключ (Список вибору)

**Контекст:** Користувач редагує форму (`Record`), і одне з полів є посиланням на іншу таблицю (зовнішній ключ), наприклад, поле "Власник" у картці собаки.

**Роль `RKey`:** `RField` для зовнішнього ключа (`owner_id`) містить вкладений `RKey`, який "знає", як отримати список можливих значень (тобто, всіх власників).

**Схема:** `Record -> Recordset (для вибору)`

**Як це працює:**

1.  У класі `Record` метод `getRField` автоматично створює об'єкт `RKey` для полів типу `ref`.
2.  Цей `RKey` містить інформацію про цільову таблицю (наприклад, `owners`).
3.  Коли користувач активує це поле в UI, логіка програми використовує цей вкладений `rkey` для створення нового `Recordset`, який покаже список всіх власників для вибору.
4.  Після вибору, `id` нового власника записується назад у поле `owner_id` вихідного `Record`.

**Приклад коду:**

```cpp
// Отримуємо поле "owner" з форми собаки
RField& ownerField = currentDog.getRField("owner");

// Це поле вже містить ключ, що веде до списку власників
const RKey& ownerLookupKey = *ownerField.rkey;

// Використовуємо цей ключ для відкриття списку вибору
Recordset ownerSelectionList(ownerLookupKey);
ownerSelectionList.load();
```

-----

## 4. Сценарій №3: Батьківсько-дочірній зв'язок (Один-до-багатьох)

**Контекст:** На формі батьківського об'єкта (`Record`) потрібно відобразити список дочірніх об'єктів (`Recordset`). Наприклад, на формі собаки показати список її цуценят.

**Роль `RKey`:** Первинний ключ батьківського `Record` (`dog.id`) використовується для фільтрації дочірнього `Recordset`. Зв'язок ініціюється через поле батька, що відповідає за цей зв'язок.

**Схема:** `Record -> RField.link -> Recordset`

**Як це працює:**
**(Оновлена логіка)**
1.  У батьківському `Record` (собака) є поле, що представляє дочірню колекцію (наприклад, віртуальне поле "puppies"). Цей `RField` має спеціальний вказівник `link`.
2.  Коли UI потребує відобразити дочірній список, він звертається до цього поля.
3.  Створюється `Recordset` для дочірніх об'єктів (цуценят).
4.  Під час завантаження даних цей `Recordset` отримує інформацію про зв'язок від батьківського `RField`. Він бачить, що має бути відфільтрованим, і автоматично додає до свого SQL-запиту умову `WHERE dog_id = [значення з батьківського RKey]`.

**Приклад коду (концептуально оновлений):**

```cpp
// Отримуємо поле "puppies", що представляє дочірню колекцію
RField& puppyCollectionField = currentDog.getRField("puppies");

// Створюємо список цуценят, передаючи інформацію про зв'язок з батьком
// puppyCollectionField.link містить всю необхідну інформацію про зв'язок
Recordset puppyList(puppyCollectionField.link);

// При завантаженні будуть обрані лише цуценята цієї собаки
puppyList.load();
```

-----

## 5. Сценарій №4: Прямий перехід за посиланням

**Контекст:** Аналогічно до сценарію №2, але замість відкриття списку для вибору, потрібно одразу перейти до детальної форми пов'язаного об'єкта.

**Роль `RKey`:** `RKey`, асоційований з полем зовнішнього ключа, використовується для прямого створення та завантаження нового `Record`.

**Схема:** `Record -> Record (пов'язаний)`

**Як це працює:**
Логіка така ж, як і в сценарії №2, але замість того, щоб передати `RKey` у `Recordset`, його передають напряму в конструктор `Record`.

**Приклад коду:**

```cpp
// Отримуємо поле "owner" з форми собаки
RField& ownerField = currentDog.getRField("owner");
const RKey& ownerKey = *ownerField.rkey;

// Замість списку, одразу створюємо картку власника
Record ownerDetails(ownerKey);
ownerDetails.load(); // Завантажуємо дані власника по id з ownerKey
```

Ці чотири сценарії повністю описують гнучку систему зв'язків, побудовану навколо універсального класу `RKey`.
Ви знову влучили в саму точку. Це абсолютно вірне і критично важливе уточнення. Я використовував термін "Master-Detail" як синонім до "Батьківсько-дочірнього зв'язку", але ви правильно вказали, що це **два різні, хоч і пов'язані, патерни**:

1.  **Батьківсько-дочірній (Parent-Child / Один-до-багатьох):** Це ієрархічний зв'язок, де одна форма (`Record`) містить в собі список дочірніх записів (`Recordset`). Приклад: Форма Проєкту та список його Завдань. **Схема: `Record -> Recordset`**. Це те, що ми щойно обговорили.

2.  **Master-Detail:** Це зв'язок на одному рівні, де список (`Recordset`) і форма (`Record`) існують поруч, і вибір у списку оновлює дані у формі. Приклад: Зліва список користувачів, справа — форма з деталями вибраного користувача. **Схема: `Recordset -> Record`**.

Ви абсолютно праві, `RKey_usage.md` не описує цей другий, "класичний" Master-Detail патерн. Давайте негайно це виправимо і спроектуємо, як наша архітектура буде його обробляти.

-----

### ## Архітектура "Master-Detail" (`Recordset -> Record`)

Хороша новина полягає в тому, що наша архітектура вже має всі необхідні компоненти для реалізації цього патерну. Нам не потрібні нові конструктори, лише правильний спосіб їх поєднати, і цю роль, знову ж таки, виконає `View`.

#### **Ключовий Принцип: Спільний `RKey`**

Ідея полягає в тому, що і список (`Recordset`), і форма (`Record`) будуть **використовувати один і той самий `RKey`**. Цей `RKey` буде належати `Recordset`-у і виступатиме як "курсор". Форма `Record` буде лише "спостерігати" за цим курсором.

#### **Як це працює на практиці:**

1.  **`View` будує інтерфейс:**

      * `View` аналізує `Layout`, який описує `list` та `form` поруч (наприклад, всередині `hbox`).
      * `View` створює екземпляр `Recordset` для "master" списку. Цей `Recordset` має свій власний, "рідний" `rkey` (`this->rkey`), який буде відстежувати поточний вибраний рядок.
      * **Ключовий крок:** `View` створює екземпляр `Record` для "detail" форми, передаючи в його конструктор **посилання на `rkey` з `Recordset`-а**.
        ```cpp
        // Псевдокод всередині View

        // Створюємо master-список
        auto masterList = std::make_unique<Recordset>(qmodelForUsers);

        // Створюємо detail-форму, передаючи їй rkey від master-списку
        auto detailForm = std::make_unique<Record>(masterList->getRKey());
        ```

2.  **Взаємодія Користувача:**

      * Користувач завантажує `View`. `masterList` заповнюється даними. Його `rkey` може вказувати на перший запис або бути порожнім. `detailForm` також завантажує дані на основі цього `rkey` і показує або перший запис, або порожню форму.
      * Користувач клікає на інший рядок у `masterList`.
      * Клієнт надсилає на сервер дію (наприклад, `SetCurrentRow`).
      * `masterList` оновлює свій внутрішній `rkey`, щоб він вказував на новообраний запис.
      * Далі `View` (або `Session`) віддає команду `detailForm->Load()`.
      * `detailForm`, викликаючи `Load()`, звертається до свого `rkey`. А оскільки цей `rkey` є **тим самим об'єктом**, що й `rkey` у `masterList`, форма автоматично завантажує дані для щойно вибраного запису.

### ## Підсумок та Оновлення Документації

Ви знову допомогли виявити і закрити важливу прогалину.

  * **Патерн реалізовано:** Наша архітектура легко підтримує Master-Detail через спільне використання `RKey` між `Recordset` та `Record`, оркестроване шаром `View`.
  * **Документація:** Я пропоную додати до `RKey_usage.md` новий розділ, "Сценарій №5: Master-Detail (`Recordset -> Record`)", де буде описано цей патерн, щоб майбутні розробники мали повну картину можливостей системи.

