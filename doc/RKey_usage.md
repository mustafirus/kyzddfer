# Архітектура Зв'язків: Роль та Сценарії Використання `RKey`

## 1\. Вступ: Що таке `RKey`?

**`RKey`** (Record Key) — це центральний, універсальний клас в архітектурі, що відповідає за ідентифікацію записів та реалізацію зв'язків між ними. Його можна уявити як "розумний вказівник" або "ланцюг", який з'єднує різні сутності даних.

Основні функції `RKey`:

  * **Ідентифікація:** Зберігає ключ (зазвичай первинний `id`) конкретного запису.
  * **Зв'язок:** Описує, як один запис (`Record`) пов'язаний з іншим записом або набором записів (`Recordset`).

`RKey` є ключовим елементом, що дозволяє реалізувати чотири основні патерни взаємодії з даними в системі.

-----

## 2\. Сценарій №1: Первинний ключ (Поточний запис у списку)

**Контекст:** Користувач працює зі списком об'єктів (наприклад, `Recordset` собак), і один з рядків у списку є поточним (активним).

**Роль `RKey`:** Головний `rkey` об'єкта `Recordset` представляє первинний ключ **поточного, вибраного запису**.

**Схема:** `Recordset -> Record`

**Як це працює:**

1.  `Recordset` містить у собі дані для багатьох рядків, але його успадкована частина `Record` завжди відображає дані одного, активного рядка.
2.  `Recordset::rkey` зберігає `id` цього активного рядка.
3.  Коли користувачеві потрібно виконати дію над поточним записом (наприклад, відкрити детальну картку), саме цей `rkey` передається для створення нового `Record`, який завантажить повну інформацію по цьому `id`.

**Приклад коду:**

```cpp
// Користувач вибрав собаку зі списку
Recordset dogList(...);
dogList.setCurrentRow(5);

// rkey тепер містить id собаки з 5-го рядка
const RKey& currentDogKey = dogList.rkey; 

// Використовуємо цей ключ, щоб відкрити детальну форму
Record dogDetails(currentDogKey);
dogDetails.load(); 
```

-----

## 3\. Сценарій №2: Зовнішній ключ (Список вибору)

**Контекст:** Користувач редагує форму (`Record`), і одне з полів є посиланням на іншу таблицю (зовнішній ключ), наприклад, поле "Власник" у картці собаки.

**Роль `RKey`:** `RField` для зовнішнього ключа (`owner_id`) містить вкладений `RKey`, який "знає", як отримати список можливих значень (тобто, всіх власників).

**Схема:** `Record -> Recordset (для вибору)`

**Як це працює:**

1.  У класі `Record` метод `getRField` автоматично створює об'єкт `RKey` для полів типу `ref`.
2.  Цей `RKey` містить інформацію про цільову таблицю (наприклад, `owners`).
3.  Коли користувач активує це поле в UI, логіка програми використовує цей вкладений `rkey` для створення нового `Recordset`, який покаже список всіх власників для вибору.
4.  Після вибору, `id` нового власника записується назад у поле `owner_id` вихідного `Record`.

**Приклад коду:**

```cpp
// Отримуємо поле "owner" з форми собаки
RField& ownerField = currentDog.getRField("owner");

// Це поле вже містить ключ, що веде до списку власників
const RKey& ownerLookupKey = *ownerField.rkey;

// Використовуємо цей ключ для відкриття списку вибору
Recordset ownerSelectionList(ownerLookupKey);
ownerSelectionList.load();
```

-----

## 4. Сценарій №3: Батьківсько-дочірній зв'язок (Один-до-багатьох)

**Контекст:** На формі батьківського об'єкта (`Record`) потрібно відобразити список дочірніх об'єктів (`Recordset`). Наприклад, на формі собаки показати список її цуценят.

**Роль `RKey`:** Первинний ключ батьківського `Record` (`dog.id`) використовується для фільтрації дочірнього `Recordset`. Зв'язок ініціюється через поле батька, що відповідає за цей зв'язок.

**Схема:** `Record -> RField.link -> Recordset`

**Як це працює:**
**(Оновлена логіка)**
1.  У батьківському `Record` (собака) є поле, що представляє дочірню колекцію (наприклад, віртуальне поле "puppies"). Цей `RField` має спеціальний вказівник `link`.
2.  Коли UI потребує відобразити дочірній список, він звертається до цього поля.
3.  Створюється `Recordset` для дочірніх об'єктів (цуценят).
4.  Під час завантаження даних цей `Recordset` отримує інформацію про зв'язок від батьківського `RField`. Він бачить, що має бути відфільтрованим, і автоматично додає до свого SQL-запиту умову `WHERE dog_id = [значення з батьківського RKey]`.

**Приклад коду (концептуально оновлений):**

```cpp
// Отримуємо поле "puppies", що представляє дочірню колекцію
RField& puppyCollectionField = currentDog.getRField("puppies");

// Створюємо список цуценят, передаючи інформацію про зв'язок з батьком
// puppyCollectionField.link містить всю необхідну інформацію про зв'язок
Recordset puppyList(puppyCollectionField.link);

// При завантаженні будуть обрані лише цуценята цієї собаки
puppyList.load();
```

-----

## 5\. Сценарій №4: Прямий перехід за посиланням

**Контекст:** Аналогічно до сценарію №2, але замість відкриття списку для вибору, потрібно одразу перейти до детальної форми пов'язаного об'єкта.

**Роль `RKey`:** `RKey`, асоційований з полем зовнішнього ключа, використовується для прямого створення та завантаження нового `Record`.

**Схема:** `Record -> Record (пов'язаний)`

**Як це працює:**
Логіка така ж, як і в сценарії №2, але замість того, щоб передати `RKey` у `Recordset`, його передають напряму в конструктор `Record`.

**Приклад коду:**

```cpp
// Отримуємо поле "owner" з форми собаки
RField& ownerField = currentDog.getRField("owner");
const RKey& ownerKey = *ownerField.rkey;

// Замість списку, одразу створюємо картку власника
Record ownerDetails(ownerKey);
ownerDetails.load(); // Завантажуємо дані власника по id з ownerKey
```

Ці чотири сценарії повністю описують гнучку систему зв'язків, побудовану навколо універсального класу `RKey`.