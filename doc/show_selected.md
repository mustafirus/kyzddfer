### **Архітектурна Пропозиція: Режим Перегляду Вибраних Записів**

**Статус:** Пропозиція

#### **1. Концепція та Призначення**

**Проблема:** Користувач може вибрати записи (`selected_record_ids`) на кількох різних сторінках `Recordset`. Стандартний механізм `Load()` не дозволяє побачити всі ці записи одночасно, оскільки він прив'язаний до пагінації та основних фільтрів.

**Рішення:** Ввести спеціальний тимчасовий режим для `Recordset` — **"Режим фільтрації за вибраним"**. У цьому режимі `Recordset` тимчасово ігнорує свої основні фільтри, сортування та пагінацію і натомість відображає лише ті записи, `id` яких знаходяться у списку `selected_record_ids`. Цей режим можна вмикати та вимикати, не втрачаючи основного стану `Recordset`.

#### **2. Зміни у Протоколі (`ky.proto.txt`)**

Щоб керувати цим режимом, нам потрібні зміни в контракті з клієнтом.

**2.1. Новий RPC-виклик**

Додаємо до сервісу `ViewService` новий метод для ввімкнення/вимкнення цього режиму.

```proto
service ViewService {
  // ... існуючі rpc ...

  /// Вмикає або вимикає для вказаного Recordset режим, в якому
  /// відображаються лише вибрані записи.
  rpc SetSelectionFilter (SetSelectionFilterReq) returns (UpdateResponse) {}
}

message SetSelectionFilterReq {
  Id32 rec_id = 1; // RUID of the Recordset
  bool is_active = 2; // true - увімкнути режим, false - вимкнути
}
```

**2.2. Новий прапорець у стані `Recordset`**

Щоб клієнт знав, у якому режимі наразі перебуває `Recordset`, додаємо новий прапорець до повідомлення `Recordset`.

```proto
message Recordset {
  // ... існуючі поля ...
  
  // НОВЕ ПОЛЕ:
  // Показує, що Recordset наразі перебуває в режимі
  // відображення лише вибраних записів.
  bool is_selection_filter_active = 12;

  oneof data_representation {
    // ...
  }
  // ...
}
```

#### **3. Логіка на Сервері (`Recordset`)**

**3.1. Новий стан у класі `Recordset`**

Додаємо відповідний прапорець у C++ клас.

```cpp
// rec.h
class Recordset : public Record {
  // ...
private:
  // ...
  bool isSelectionFilterActive = false; // Прапорець для нового режиму
  // ...
};
```

**3.2. Новий метод `SetSelectionFilter()`**

```cpp
// rec.cpp
void Recordset::SetSelectionFilter(bool is_active) {
    this->isSelectionFilterActive = is_active;
    
    // Скидаємо кеш ID, щоб при наступному Load() дані перезавантажились
    // відповідно до нового режиму.
    this->pageCursorIds.reset();
}
```

**Важливо:** цей метод **не змінює** основні `filters`, `sorts` чи `pager`. Він лише перемикає режим.

**3.3. Модифікація `doLoad()`**

Метод `doLoad` стає "розумнішим". Він перевіряє, в якому режимі працює, і відповідно генерує запити.

```cpp
// rec.cpp (псевдокод для doLoad)

void Recordset::doLoad(const vector_prf& fields_to_load) {
    SqlGenius genius(this);
    auto& db = Rack::get().sqldb;

    if (this->isSelectionFilterActive) {
        // ==========================================================
        // РЕЖИМ 1: ВІДОБРАЖЕННЯ ЛИШЕ ВИБРАНИХ
        // ==========================================================
        
        // Крок 1: total_count дорівнює кількості вибраних.
        this->total_count = this->selected_record_ids.size();
        
        // Крок 2: pageCursorIds - це зріз з selected_record_ids
        // відповідно до поточного пейджера.
        // (Тут потрібна логіка для пагінації по std::unordered_set).
        
        // Крок 3: Завантажуємо дані для цих ID.
        // ...

    } else {
        // ==========================================================
        // РЕЖИМ 2: СТАНДАРТНА РОБОТА (наша поточна реалізація)
        // ==========================================================
        
        // --- КРОК 1: Завжди отримуємо актуальну загальну кількість записів ---
        // ... (поточна логіка) ...

        // --- КРОК 2: Завантажуємо ID для поточної сторінки (лише за потреби) ---
        // ... (поточна логіка) ...

        // --- КРОК 3: Завантажуємо повні дані для ID поточної сторінки ---
        // ... (поточна логіка) ...
    }

    // ... фінальна частина з res, fields_in_last_query, cursor_idx_for_next ...
}
```

#### **4. Потік Взаємодії**

1.  Користувач вибирає записи на різних сторінках. `selected_record_ids` наповнюється.
2.  Користувач натискає кнопку "Показати вибране". Клієнт надсилає `SetSelectionFilter({rec_id, true})`.
3.  Сервер встановлює `isSelectionFilterActive = true` і викликає `Load()`.
4.  `doLoad` бачить прапорець, ігнорує основні фільтри і завантажує дані на основі `selected_record_ids`.
5.  Користувач натискає "Показати всі". Клієнт надсилає `SetSelectionFilter({rec_id, false})`.
6.  Сервер встановлює `isSelectionFilterActive = false` і викликає `Load()`.
7.  `doLoad` бачить, що прапорець знято, і повертається до роботи зі своїми основними фільтрами та сортуванням. Стан `Recordset` миттєво відновлюється.
