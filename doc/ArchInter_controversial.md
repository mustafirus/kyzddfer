## Архітектура Взаємодії: Core, gRPC та Потік Даних (v3.1)

Мета цієї архітектури — забезпечити ефективний потік даних від бази даних до Protobuf-серіалізації, зберігаючи повну незалежність ядра системи (`libkycore`) і мінімізуючи копіювання даних.

### 1. Головний Принцип: Незалежність Ядра (`libkycore`)

Основою системи є ядро `libkycore`, центральним файлом якого є `rack.h`.
* **Повна незалежність:** Ядро `libkycore` **не повинно мати жодних залежностей** від зовнішніх систем, таких як **gRPC** чи **Protobuf**.
* **Центр логіки:** Всі бізнес-об'єкти, такі як `ky::Record` та `ky::Recordset`, та їхня логіка інкапсульовані всередині ядра.
* **Одностороння залежність:** Усі інші модулі системи (наприклад, шар gRPC) залежать від `libkycore`, але не навпаки.

---

### 2. Керування Станом в `RField`: Реалізація Гібридної Моделі

Основна мета цієї моделі — досягти максимальної продуктивності при читанні даних і водночас забезпечити надійне зберігання змінених значень. Ця логіка інкапсульована всередині кожного об'єкта `ky::RField`.

Стан кожного поля розподілений між кількома змінними-членами, які працюють у тандемі для управління даними.

#### Ключові компоненти в `RField`

Згідно з реалізацією у файлі `rec.h`, для управління станом використовуються такі поля:

  * `sv val;`: Це `string_view`, неволодіючий вказівник на дані. Він є основним інтерфейсом для читання значення поля. Залежно від стану, він вказує або на буфер бази даних, або на внутрішній буфер `mval`.
  * `std::string mval;`: Це приватне поле типу `string`, яке **володіє** даними. Воно використовується для зберігання значення, яке було змінено клієнтом.
  * `bool is_modified;`: Прапорець, який чітко вказує, чи було поле змінено після завантаження з БД.
  * `bool is_null;`: Прапорець для відстеження `NULL`-стану поля.

  #### Сценарій 1: Завантаження даних з бази даних (Режим "Read-Only")

  Цей сценарій активується при виклику методу `RField::set(optsv from_db)`.

    1.  **Встановлення стану**: Прапорець `is_modified` встановлюється в `false`.
    2.  **Нульове копіювання**: `sv val` напряму встановлюється так, щоб вказувати на область пам'яті, надану драйвером бази даних (`SqlDB::Result`). Це дозволяє уникнути будь-якого копіювання даних на цьому етапі.
    3.  **Внутрішній буфер не використовується**: Володіюче поле `mval` очищується (`mval.clear()`) і не використовується.

    **Результат**: Поле працює в режимі максимальної продуктивності. Дані читаються напряму з буфера результатів SQL-запиту без жодних зайвих копій, що ідеально для швидкого відображення списків.

  #### Сценарій 2: Зміна даних клієнтом (Режим "Editable")

  Цей сценарій активується при виклику методу `RField::modify(optsv from_client)`.

    1.  **Встановлення стану**: Прапорець `is_modified` встановлюється в `true`.
    2.  **Копіювання та володіння**: Значення, отримане від клієнта, **копіюється** у внутрішнє, володіюче поле `std::string mval`. З цього моменту `RField` несе повну відповідальність за час життя цих даних.
    3.  **Перенаправлення `val`**: Публічний `string_view val` "переключається" і тепер вказує на внутрішній буфер `mval` (`val = mval;`).

    **Результат**: Поле переходить у безпечний режим редагування. Дані надійно зберігаються всередині об'єкта `RField`. Будь-який подальший доступ до значення через `val` буде повертати вже змінене значення з `mval`, гарантуючи консистентність стану.

---

### 3. Ролі Ключових Компонентів

* **`ky::Record` та `ky::Recordset`:** Це "живі" об'єкти на сервері, що керують бізнес-логікою. Їхній стан розподілений: дані — в колекції `RField`, метадані стану — в `RecordParams`.

* **gRPC-обробник:** Шар-посередник, який оркеструє процес серіалізації:
    1.  Приймає запит від клієнта (наприклад, `Reload`).
    2.  Знаходить відповідний C++ об'єкт `ky::Record`.
    3.  **Ітерує** по колекції `rfields` об'єкта `Record`.
    4.  Для кожного поля `RField` він виконує дві дії:
        * Отримує **значення** з `rfield.value` (`variant`).
        * Отримує **метадані стану** (`modified`, `id`) з відповідного запису в `record_params_.fields`.
    5.  На основі цих даних **формує** Protobuf-повідомлення для відправки клієнту.

---

### 4. Прямий Потік Даних: від `SqlDB::Result` до Protobuf

Для максимальної ефективності при завантаженні списків (операція `Reload`) використовується підхід, що мінімізує створення проміжних об'єктів та копіювання даних. Потік даних організований таким чином, щоб інформація з бази даних потрапляла в Protobuf-повідомлення якомога прямішим шляхом.

**Основний принцип:** Замість того, щоб `Recordset` створював повноцінний C++ об'єкт `ky::Record` для кожного рядка з бази даних, а потім серіалізував його, логіка серіалізації працює безпосередньо з "сирим" результатом SQL-запиту.

#### Механізм Реалізації

1.  **Запит до БД**: Клас `ky::Recordset` виконує SQL-запит і зберігає весь результат у своєму полі `std::unique_ptr<SqlDB::Result> res`. Цей об'єкт містить усі рядки та колонки, отримані від драйвера БД.

2.  **Пряма ітерація**: Зовнішня функція-серіалізатор (наприклад, у шарі gRPC-обробника) отримує доступ до цього `SqlDB::Result`. Вона ітерує безпосередньо по рядках (`result->row_count()`) та колонках (`result->column_count()`) цього результату.

3.  **Заповнення Protobuf**: Для кожної комірки в `SqlDB::Result` серіалізатор:
    * Отримує її значення у вигляді `string_view` (уникаючи копіювання на цьому етапі).
    * Знаходить метадані для поточної колонки (наприклад, `roid` поля).
    * Створює відповідне Protobuf-повідомлення `kyproto::FieldValue`.
    * Виконує **єдине необхідне копіювання** даних: з `string_view` безпосередньо в поле `bytes value` Protobuf-повідомлення `FieldValue`.

#### Переваги підходу

* **Висока продуктивність**: Цей метод уникає накладних витрат на створення та заповнення сотень або тисяч об'єктів `ky::Record` у пам'яті сервера лише для того, щоб одразу їх серіалізувати.
* **Мінімізація копіювання**: Досягається мета "одного копіювання", що значно зменшує навантаження на процесор та пам'ять.
* **Розділення відповідальності**: `Recordset` відповідає за отримання даних, а логіка gRPC-шару — за їхню фінальну серіалізацію в потрібний формат. При цьому курсорний механізм (`Recordset::next()`) залишається доступним для внутрішньої бізнес-логіки на сервері, де потрібна об'єктна модель.
