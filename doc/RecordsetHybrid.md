Гаразд, ось текст з цього документа:

### Архітектурний патерн: Гібридна модель даних в `Recordset`

Для досягнення максимальної гнучкості та продуктивності, `Recordset` використовує гібридний підхід до представлення даних. Замість того, щоб мати окремі сутності для списків, призначених лише для читання, та для редагованих списків, `Recordset` може містити дані в одному з двох форматів. Вибір формату залежить від конкретної задачі, яку виконує `View`, і визначається сервером.

В основі цього підходу лежить поле `oneof data_representation` всередині повідомлення `Recordset`, яке дозволяє серверу надсилати дані або як `Dataset`, або як `Records`.

-----

### Формат 1: `Dataset` (для швидкості та ефективності)

**Призначення:** Цей формат використовується для швидких, "пласких", **read-only** списків. Це ідеальний вибір для сценаріїв, де пріоритетом є максимальна продуктивність та мінімальне навантаження.

**Типові випадки використання:**

  * Довідники для вибору значень.
  * Звіти та аналітичні таблиці.
  * "Master" частини в master-detail інтерфейсах, де список слугує лише для навігації.

**Структура:**
`Dataset` — це максимально полегшене представлення табличних даних. Він складається з масиву рядків (`Row`), де кожен рядок — це просто масив "сирих" значень у форматі `bytes`.

```proto
message Dataset {
  message Row {
    repeated bytes values = 1; // Значення колонок
    bytes null_mask = 2;      // Бітова маска для NULL-значень
  }
  repeated Row row = 1;
}
```

**Ключові переваги:**

  * **Максимальна продуктивність:** Відсутність складної вкладеної структури та метаданих для кожного поля робить серіалізацію та парсинг на клієнті надзвичайно швидкими.
  * **Мінімальний трафік:** Передаються лише "сирі" дані, без зайвої інформації про стан (`is_modified`, `is_null` для кожного поля), що значно зменшує обсяг мережевих пакетів.
  * **Низьке споживання пам'яті:** На сервері та клієнті така структура займає мінімум ресурсів, що дозволяє ефективно працювати з десятками тисяч записів.

-----

### Формат 2: `Records` (для повноцінного редагування)

**Призначення:** Цей формат використовується для **повноцінних редагованих списків**, де кожен рядок є самостійним, повноцінним об'єктом даних.

**Типові випадки використання:**

  * Редагування рядків у документі (наприклад, товари в рахунку).
  * Табличні форми, де користувач може вносити зміни безпосередньо в комірки.
  * Будь-які сценарії, де список є не просто "вітриною", а активним інструментом для роботи з даними.

**Структура:**
Замість "плаского" набору даних, цей формат містить масив повноцінних об'єктів `Record`.

```proto
message Records {
  repeated Record items = 1;
}

message Record {
  Id32 rec_id = 1;
  repeated FieldValue fields = 2;
  bool is_modified = 3;
  
  message FieldValue {
    Id32 field_id = 1;
    bytes value = 2;
    bool is_null = 3;
    bool is_modified = 4;
  }
}
```
**Примітка щодо реалізації**: Хоча протокол Record містить прапорець is_modified , у серверній реалізації ky::Record цей прапорець відсутній. "Брудний" стан запису визначається динамічно шляхом ітерації по прапорцях is_modified у його дочірніх полях RField. Це зроблено для уникнення дублювання стану, оскільки ітерація по полях все одно необхідна для серіалізації даних.

**Ключові переваги:**

  * **Збереження ідеології:** Цей підхід повністю відповідає ключовому принципу архітектури: **"редагується тільки `Record`"**. Коли користувач редагує рядок у списку, він насправді редагує один з `Record`-ів у цій колекції.
  * **Детальне відстеження змін:** Кожен рядок (будучи об'єктом `Record`) має власну систему відстеження змін. Сервер точно знає, не тільки який рядок змінився, але і які саме поля в ньому були змінені, завдяки прапорцям `is_modified`.
  * **Атомарність та надійність:** При збереженні (`Save`) сервер отримує повний стан кожного зміненого запису, що дозволяє виконувати складні валідації та транзакції надійно.

### Висновок

Гібридний підхід дозволяє системі бути одночасно **швидкою там, де це потрібно** (використовуючи `Dataset`), і **потужною та надійною там, де потрібне редагування** (використовуючи `Records`), не створюючи при цьому зайвих сутностей і не ускладнюючи протокол.