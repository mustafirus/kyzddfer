#### Дискусія щодо `Refresh` та `Undo`

**Етап 1: Початкова плутанина**

Спочатку в протоколі були методи `Reload` ("перезавантажити з нуля") та `Refresh` ("оновити незмінені поля"). Це створювало плутанину:
* Яку операцію викликати для скасування змін?
* Яку — для оновлення даних від інших користувачів?
* До чого вони застосовуються — до одного запису (`Record`) чи до всього екрану (`View`)?

**Етап 2: Розділення за призначенням (`Undo` vs. `Refresh`)**

Ми дійшли висновку, що це дві принципово різні задачі:
* **`Undo`** — це дія користувача для **скасування власних, ще не збережених, помилок**.
* **`Refresh`** — це дія для **синхронізації з сервером**, щоб побачити зміни, зроблені іншими користувачами.

**Етап 3: Визначення об'єкта дії (найважливіший етап)**

Тут у нас була найдовша дискусія. Спочатку ми думали застосовувати ці операції до окремих компонентів (`Record`), але ви справедливо зауважили, що це не відповідає досвіду користувача.

Ваша ключова ідея, яка визначила фінальну архітектуру, полягала в наступному:
> **Undo** — це не покрокове скасування, а глобальна операція **"повернути до збереженого стану"** для **всього, що є на поточному екрані (`View`)**. Це аналог послідовності "Закрити, не зберігаючи" -> "Відкрити заново".

Це означає, що якщо користувач на одному екрані змінив і форму замовлення, і додав товар у списку, то одна команда `Undo` має скасувати **обидві** ці зміни.

**Етап 4: Фінальна архітектура**

Виходячи з вашої ідеї, ми прийшли до простого та потужного рішення:
1.  **Обидві операції (`Undo` та `Refresh`) застосовуються до всього активного `View`**. Ми не чіпаємо весь стек (`ViewStack`), а працюємо лише з тим екраном, який бачить користувач.
2.  **Обидва методи знаходяться в `ViewService`** і не приймають параметрів (`Empty`), оскільки сервер завжди знає, який `View` є активним для поточної сесії.
3.  **Обидва методи повертають `UpdateResponse`**, який містить "чисті" версії всіх компонентів (`Record`, `Recordset`) з цього `View`.

Таким чином, ми отримали два чіткі, передбачувані та потужні інструменти, які повністю відповідають ментальній моделі кінцевого користувача.
