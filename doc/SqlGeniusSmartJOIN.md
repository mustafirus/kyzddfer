### ## Архітектура: "Розумний JOIN" у `SqlGenius`

Ідея полягає в тому, що `SqlGenius`, будуючи запит для `Load()` або `Refresh()`, стає трохи "розумнішим". Коли йому потрібно додати `JOIN` для отримання залежних полів (наприклад, `author.name`), він перевіряє стан поля, за яким відбувається зв'язок (`author`).

**Алгоритм:**

1.  **Контекст:** Користувач у формі Книги вибрав нового Автора. `RField` для поля `author` тепер має прапорець `is_modified = true`, а його `val` містить `id` нового автора. `Record` ще не збережено.

2.  **Дія:** Система ініціює оновлення `View` (через `Return` чи `Refresh`), що призводить до виклику `bookRecord->Load()`.

3.  **Робота `SqlGenius`:**

      * `SqlGenius` отримує завдання згенерувати `SELECT` для `bookRecord`, який включає поля `title`, `author` та `author.name`.

      * Для того, щоб отримати `author.name`, він розуміє, що потрібно приєднати (`JOIN`) таблицю `authors`.

      * Він дивиться на поле, за яким буде відбуватися `JOIN` — це `RField` **`author`**.

      * **Ключовий момент:** `SqlGenius` перевіряє `author->is_modified`.

          * **Сценарій А (Поле НЕ змінено): `is_modified == false`**
            `SqlGenius` генерує стандартний `JOIN`, покладаючись на дані, що вже є в базі:

            ```sql
            LEFT JOIN authors a ON books.author_id = a.id
            ```

          * **Сценарій Б (Поле змінено): `is_modified == true`**
            `SqlGenius` розуміє, що покладатися на `books.author_id` вже не можна, бо користувач щойно вибрав нове значення, яке ще не збережене. Тому він генерує `JOIN`, використовуючи **нове значення** з `RField` як параметр:

            ```sql
            LEFT JOIN authors a ON a.id = $new_author_id -- ($1)
            ```

            ...де значення для `$new_author_id` він візьме прямо з `author->val`.

4.  **Результат:**

      * `SqlGenius` створює **один-єдиний, ефективний SQL-запит**, який за один раз витягує з бази даних всю актуальну інформацію, включаючи залежні поля від щойно обраного, але ще не збереженого, автора.
      * Немає жодного "tempRecordHell", немає зайвих запитів до бази.

### ## Висновок

Ваша ідея є ідеальною, тому що:

  * **Вона проста:** Ми не додаємо нових методів чи класів, а лише трохи розширюємо інтелект існуючого `SqlGenius`.
  * **Вона дотримується поділу відповідальності:** `SqlGenius` залишається відповідальним за SQL і нічого не знає про `Layout`. `Record` залишається контейнером даних.
  * **Вона ефективна:** Все вирішується одним запитом до бази даних.

