### **Концепція Ky-DataFlow: The R/R Model (на противагу CRUD)**

**rev**: 2

Архітектура **Ky-DataFlow**, що базується на моделі **R/R (Record/Recordset)**, дозволяє нам:

* **Досягти максимальної продуктивності та гнучкості**, чітко розділивши відповідальність: `Recordset` використовується для швидкого читання та формування будь-яких списків даних, тоді як `Record` інкапсулює надійні атомарні операції (INSERT, UPDATE, DELETE) над одним записом.

* **Гарантувати 100% консистентність даних** між додатком і базою даних завдяки ключовому принципу "Read-after-Write", за яким після кожної зміни запису його стан негайно перезавантажується з бази, враховуючи будь-яку логіку на її боці, як-от тригери чи обчислювані поля.

* **Забезпечити точність та функціональність на рівні бізнес-логіки**, оскільки операція `UPDATE` надсилає на сервер лише ті поля, які дійсно були змінені користувачем ("dirty" fields). Це дозволяє: **Уникнути "затирання" даних:** Зміни, зроблені одним користувачем, не перезапишуть зміни в інших полях цього ж запису, які паралельно міг внести інший користувач. **Надати точну інформацію тригерам:** Будь-яка логіка на стороні бази даних (тригери, функції) отримує чіткий сигнал про те, яке саме поле було змінено, що є критично важливим для складних бізнес-правил.

* **Забезпечити повний контроль над логікою**, де клієнт лише надсилає ідентифікатор **Дії**, а сервер централізовано керує станом, що унеможливлює будь-які маніпуляції.

Замість чотирьох простих операцій, ваша система розділяє відповідальність між двома ключовими сутностями: `Recordset` та `Record`.

1. **Read (Читання) — Розділено на два патерни:**
   * **Читання списків:** За це відповідає **виключно `Recordset`**. Це потужний конструктор `SELECT`-запитів, який вміє працювати з фільтрами, сортуванням, пагінацією — тобто з будь-якими вибірками даних.
   * **Читання одного запису:** За це відповідає **`Record::Load()`**. Його завдання — завантажити один конкретний запис за його `id`.

2. **Create (Створення) — Непряма операція:**
   * Процес не починається з команди "Create". Він починається з виклику `Recordset::New()`, який готує "порожній" об'єкт `Record`.
   * Після того, як клієнт заповнив поля, він викликає `Record::Save()`.
   * Саме `Save()` для нового об'єкта генерує `INSERT`.

3. **Update (Оновлення) — "Розумна" операція:**
   * `Record` відстежує, які саме поля були змінені ("dirty fields") за допомогою прапорця `is_modified`.
   * При виклику `Save()` для існуючого запису, `SqlGenius` генерує `UPDATE`-запит, що містить **лише змінені поля**, що є ключовою оптимізацією.

4. **Delete (Видалення) — є контекстуальною:** і реалізує той самий принцип розділення відповідальності, що й операції читання:
   * **`Record::Delete()`** використовується для атомарного видалення одного запису, коли користувач працює з ним у формі.
   * **`Recordset::Delete()`** використовується для групових операцій зі списком — видалення одного (активного) або кількох (виділених) записів.

5. **Undo (Скасування) — Глобальна операція повернення:**
   * `Undo` — це операція, що ініціює повернення до збереженого стану.
   * Це аналог послідовності "відкинути зміни та перезавантажити".

6. **Refresh (Оновлення) — Синхронізація з сервером:**
   * `Refresh` — це операція для **синхронізації з сервером**, щоб отримати зміни, зроблені іншими користувачами не чіпаючи модифіковані поля.
   
### **Ключовий Принцип: "Read-after-Write"**

І найголовніше, що відрізняє цю модель — це принцип **"Прочитай після запису"**. Після будь-якої операції, що змінює дані (`INSERT` чи `UPDATE`), `Record` **завжди** автоматично виконує `SELECT`, щоб перезавантажити свій стан з бази даних.

Це гарантує, що стан об'єкта в пам'яті на 100% відповідає стану в БД, враховуючи будь-яку логіку на стороні бази даних (тригери, значення за замовчуванням, обчислювані поля). Це робить систему надзвичайно надійною.



### Особливості реалізації

### 1. Чому `RKey` є і в `Record` і в `Recordset`?

Якщо коротко: бо вони виконують **різні, але пов'язані ролі**, що є основою архітектури **Ky-DataFlow**.

#### **Роль `RKey` в `Recordset`**

`Recordset` є списком (наприклад, таблицею), але в будь-який момент часу один з його рядків є **поточним** або **активним**.

  * `RKey`, що є власним членом класу `Recordset` (`RKey rkey;`), відповідає за ідентифікацію саме цього **активного рядка**. Він зберігає його `id` і метадані.

#### **Роль `RKey` в `Record`**

Клас `Recordset` успадковує `Record` (`class Recordset : public Record`). Це означає, що `Recordset` — це не просто список, а "список, який одночасно поводиться як один запис". Цей "один запис" — це і є поточний, активний рядок.

  * Базовий клас `Record` потребує посилання на `RKey` (`const RKey& rkey;`), щоб знати, дані якого саме запису він має відображати.

#### **Магія в Конструкторі**

Ключова логіка зв'язку знаходиться в конструкторі `Recordset`:

```cpp
Recordset::Recordset(QModel& qmodel) : Record(rkey) { /*...*/ }
```

1.  При створенні об'єкта `Recordset` спочатку створюється його власний член `RKey rkey`.
2.  Потім цей самий, щойно створений `rkey`, передається в конструктор базового класу `Record`.

Таким чином, `Record`, що є "вбудованим" у `Recordset`, завжди посилається на `RKey` свого "власника" — `Recordset`-а. Це створює елегантний зв'язок: коли ви змінюєте активний рядок у `Recordset`, дані, які відображаються через методи його базової частини `Record`, автоматично оновлюються, бо вони дивляться на той самий `RKey`.

-----

### 2. Чому метод `Load()` не віртуальний?

Тому що логіка завантаження для `Record` та `Recordset` є **фундаментально різною** і вони **ніколи не використовуються поліморфно** в контексті цього методу.

  * **`Record::Load()`**: Його єдине завдання — завантажити **один** конкретний запис за його `id`. Для цього він викликає `SqlGenius::gen_select_one()`. Це проста й атомарна операція.

  * **`Recordset::Load()`**: Його завдання набагато складніше. Він реалізує ефективний **3-кроковий процес завантаження** для цілого списку:

    1.  Отримати загальну кількість записів (`gen_select_count`).
    2.  Отримати `id` записів для поточної сторінки з урахуванням фільтрів та сортування (`gen_select_ids`).
    3.  Завантажити повні дані лише для цих `id` (`gen_select_by_ids`).

Хоча обидва методи називаються `Load()`, бо вони виконують концептуально схожу дію ("завантажити дані"), їхні реалізації не мають нічого спільного.

**Чому `virtual` тут не потрібен і навіть шкідливий?**

Роблячи метод віртуальним, ви припускаєте, що може існувати код, який матиме вказівник на базовий клас (`Record*`) і захоче викликати для нього `Load()`, очікуючи, що для `Recordset` виконається його власна, складна версія.

Але ваша архітектура так не працює. Код завжди чітко знає, з чим він має справу: з формою (і тоді викликає `Record::Load()`) чи зі списком (і викликає `Recordset::Load()`). Немає сценарію, де ці два об'єкти були б взаємозамінними в контексті завантаження.

Це класичний випадок **"приховування імені" (name hiding)**, а не поліморфізму. Обидва класи мають однойменний метод, але вони не пов'язані віртуальним механізмом, бо їхні завдання кардинально відрізняються.

Зрозумів. Ви хочете, щоб пояснення працювало як **архітектурний патерн**: щоб інший розробник, прочитавши його, не просто зрозумів, "чому це працює", а й побачив "чому це єдино правильний шлях" і не намагався "покращити" його, зламавши закладену логіку.

Це дуже тонкий і важливий момент. Давайте спробуємо.

-----

### **Архітектурний Патерн: Безпека `SetFilter(RField&)`**

На перший погляд, сигнатура методу `SetFilter(RField& rfield, ...)` може викликати занепокоєння: "Що, якщо сюди випадково передадуть `RField` від іншого `Recordset`?". Ця архітектура унеможливлює таку помилку завдяки двом рівням захисту: **зовнішньому контракту** та **внутрішньому потоку управління**.

**Захист `SetFilter(RField&)` забезпечується чітким потоком операцій:**
1.  За `ruid`, що надійшов від клієнта, знаходиться конкретний об'єкт `RField`.
2.  Через його поле `owner` миттєво отримується його власник — `Recordset`.
3.  Перевіряється, чи цей `Recordset` є легальним у поточному контексті (наприклад, чи належить він активному `View`).
4.  Викликається метод `SetFilter` для цього, і тільки цього, `Recordset`-а.

Такий потік **архітектурно унеможливлює** помилку, коли `RField` від одного об'єкта міг би бути застосований до іншого.

Це два чудових, глибоких питання, які стосуються надійності та гнучкості архітектури. Відповіді на них розкривають ключові принципи, закладені в дизайн `Recordset`.

-----

### Чому `next()` не використовує `visible_fields` напряму?

Це питання про гнучкість архітектури. `next()` не використовує `visible_fields` напряму, тому що **поля, які потрібно завантажити, не завжди збігаються з полями, які бачить користувач.**

1.  **Розділення Відповідальності:**
    * `visible_fields` відповідає на питання: "Що наразі **показано** користувачу?".
    * Вектор полів, що зберігається всередині `res->rfields`, відповідає на питання: "Що було **реально завантажено** з бази даних?".

2.  **Сценарії, коли вони не збігаються:**
    * **Приховані Ключі:** У списку може відображатися ім'я менеджера (`manager_name`), але для коректної роботи кнопки "Перейти до менеджера" системі потрібно також завантажити його ID (`manager_id`), навіть якщо ця колонка прихована. У цьому випадку `doLoad` буде викликаний зі списком, що містить і видимі, і приховані поля.
    * **Внутрішні Потреби:** Інша частина системи (наприклад, модуль звітів) може викликати `doLoad` з абсолютно кастомним набором полів, необхідним для своїх розрахунків, повністю ігноруючи те, що налаштовано у `visible_fields`.

**Висновок:**
Метод `next()` має працювати з тим, що **фактично лежить у буфері даних (`res`)**. Вектор полів у `res->rfields` є "маніфестом" або "змістом" для завантаженого набору даних. Використовуючи цей "маніфест", `next()` гарантує, що він коректно зіставить колонку №3 з результатом запиту з полем №3 у списку полів, з яким цей запит генерувався. Це робить механізм курсора надійним, гнучким і незалежним від поточних налаштувань відображення.
