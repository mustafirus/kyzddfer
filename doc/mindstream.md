**Запит 7:**
*тепер поговоримо про архітектуру.*
*як ти вже помітив*
  *- Recordset тільки для селектів але в безлічі варіантів*
  *- Record для select insert update delete зі змінним набором полів але завжди "where id=..." (крім insert - там автосеріал)*

---
**Запит 8:**
*чудово - поїхали далі...*
 *- release_prepared(prepared_stmt*) звільняє тільки дані - бо сам prepared statement кешується в мапі sqltext->prepared_statement*
 *- ця мапа працює по принципу zfs arc і сама пидаляє непотрібні prepared_statement*

---
**Запит 9:**
*згоден "Повноцінна реалізація ARC може бути складною." тому не будемо переборщувати*
*поїхали далі...*
*1. для генерації кляузи where використовується переважно RecordsetParams, який поїде на клієнта разом з даними щоб він знав що він отримав. Взагалі з RecordsetParams яка історія - клієнт посилає окремі компоненти RecordsetParams, бо людина ніколи не може сформувати одразу що вона хоче. Людина дивиться шо приїхали а потім додає щось(чи прибирає) і так по колу. У мене була дилема:*
*- на чергову дію юзера формувати повний RecordsetParams і відправляти на сервер*
*- на чергову дію юзера відправляти дію а на сервер формувати повний RecordsetParams і відправляти на клієнта разом з даними.*
*тут головне питання - хто папік - я подумав шо краще це буде сервер, навіть якщо можливо це і не оптимально*
*2. для генерації кляузи where,  у деяких моментах, також використовується дані з RField в якості параметрів, тому важливо зробити підтримку цього в RField.*
*3. vector з параметрів має лежати в Recordset, і тут важливо не заплутатися бо конструкція може бути складною. До речі в старому проєкті собаководів у мене були запити складені більше ніж 16 таблиц, я чому пам'ятаю число 16 бо MSSQL того часу загибався коли таблиц було більше ніж 16 - тому доводилось сплітіть запити на частини*

---
