Знову та сама проблема. Перепрошую. Схоже, дійсно є якась проблема з відображенням блоків коду в Markdown.

Давайте без форматування. Ось фінальний текст документації у вигляді звичайної відповіді.

-----

# Технічний опис класу View

**Версія:** 1.0
**Rev:** 24

Цей документ описує архітектуру та реалізацію класу `View`, який є центральним компонентом для взаємодії користувача з даними та їх візуального представлення.

## 1. Загальна концепція

`View` є динамічним представленням, яке бачить кінцевий користувач. Його можна уявити як окрему "сторінку" або "екран" у додатку. Основою для кожного `View` слугує статичний `Layout` (макет), визначений у метаданих `libkycore`. `Layout` діє як шаблон, що описує структуру.

Ключові характеристики `View`:

  * **Цілісність:** `View` — це самодостатня, атомарна одиниця. Усі операції, такі як створення, завантаження, збереження та закриття, застосовуються до `View` як до єдиного цілого, а не до його окремих частин.
  * **Відображення даних:** `View` може містити (або не містити) об'єкти `Record` та `Recordset` для роботи з даними. Ці об'єкти можуть бути пов'язані між собою для створення складних інтерфейсів "master-detail".
  * **Формат Protobuf:** На відміну від `Layout`, який існує у вигляді метаданих на сервері, `View` використовує представлення цього макета у форматі Protobuf (`kyproto::Frame`). Це робить `View` готовим до серіалізації та передачі на клієнт, який уже сам вирішує, як саме його візуалізувати.

## 2. Структура даних

### 2.1. Навігація між View

`View` не існують ізольовано. Вони організовані в послідовність ("хлібні крихти"), яка управляється самостійно. `Session` зберігає всі останні `View` кожного із стека.

  * **Активний `View`** — це завжди останній елемент у ланцюжку пов'язаних View активного стеку. Він є головним фокусом взаємодії з користувачем. Усі команди (збереження, редагування, створення нових представлень) спрямовуються саме до цього `View` та його компонентів. Він є повністю інтерактивним (read-write).
  * **Неактивний (попередній) `View`** — це будь-який інший `View` у стеку, крім останнього. Хоча клієнт може відображати його (наприклад, як неактивну вкладку на фоні), він знаходиться у "замороженому" стані (read-only). Будь-яка взаємодія з ним заблокована. Щоб зробити попередній `View` знову активним, необхідно закрити поточний активний `View` (і всі, що знаходяться над ним у стеку).
  * **Перемикання між стеками `View`** - користувач може перемикатися між стеками View, при цьому останній View в стеку стає активним.

### 2.2. Внутрішня композиція View

Всередині `View` містить такі ключові компоненти:

  * **`void* dto`:** Непрозорий вказівник на кореневий об'єкт DTO (Data Transfer Object), зазвичай `kyproto::Frame*`. `View` володіє цим об'єктом, але, оскільки він не знає його конкретного типу, він не може видалити його напряму. Замість цього, транспортний шар, який створює DTO, також надає функцію для його видалення (напр., `kyproto::killDto(void* dto)`). Деструктор `View` відповідає за виклик цієї функції для коректного звільнення пам'яті.
  * **`Record`:** `View` володіє набором логічних об'єктів для роботи з даними. Оскільки `Recordset` є похідним від `Record`, вони зберігаються в одній поліморфній колекції.

Для забезпечення гнучкості та інкапсуляції реалізовано **двосторонній зв'язок**:

  * **`View` -\> `Record`:** `View` знає про всі об'єкти даних, якими володіє.
  * **`Record` -\> `View`:** Кожен об'єкт `Record` (та `Recordset`) містить посилання (вказівник) на `View`, якому він належить. **Призначення цього зв'язку** — дозволити об'єкту даних ініціювати дії на рівні представлення, наприклад, запросити створення нового `View` (у відповідь на дію `showDetails`), не маючи прямого доступу до сесії чи навігаційного ланцюжка.

#### 2.2.1. Структура класу (псевдокод)

Для кращого розуміння, ось основні залежності та члени класу `View`:

```cpp
// --- Зовнішні залежності з транспортного шару ---
namespace kyproto {
    // Створює DTO-каркас на основі Layout
    void* makeDto(const ky::Layout* layout, std::map<const ky::LayoutNode*, void*>& nodeToDtoMap);
    // Видаляє DTO-об'єкт, на який вказує void*
    void killDto(void* dto);
    // Створює та повертає DTO для одного Record/Recordset
    void* fillDtoFromRecord(const ky::Record* record);
}

// --- Псевдокод класу View ---
class View {
private:
    // --- Члени класу ---

    /// Непрозорий вказівник на кореневий DTO (kyproto::Frame), яким володіє View.
    void* dto;

    /// Поліморфна колекція об'єктів Record та Recordset, якими володіє цей View.
    std::map<roid_t, std::unique_ptr<Record>> records;
};
```

## 3. Основні обов'язки та функціонал

### 3.1. Створення та життєвий цикл

#### 3.1.1. Процес ініціалізації View

Створення нового екземпляра `View` — це двоетапний процес, що відбувається всередині його конструктора:

1.  **Підготовка каркаса DTO**:

      * Викликається зовнішня фабрична функція `kyproto::makeDto(layout, nodeToDtoMap)`.
      * Ця функція, що живе в транспортному шарі, рекурсивно обходить `Layout`, створює повний каркас `kyproto::Frame` з усіма вкладеними `kyproto::Record` і `kyproto::Recordset`.
      * `View` отримує від неї дві речі: непрозорий вказівник на кореневий `kyproto::Frame` (який зберігається в `View::dto`) та мапу `map<const LayoutNode*, void*>`, що пов'язує кожен вузол `Layout` з відповідним йому `dto`.

2.  **Створення логічних об'єктів та зв'язків**:

      * `View` запускає **власний рекурсивний обхід** дерева `Layout`.
      * Для кожного вузла `LayoutNodeForm/List`, який він зустрічає:
        а. `View` створює відповідний логічний об'єкт `ky::Record` або `ky::Recordset`.
        б. Використовуючи поточний `LayoutNode*` як ключ, він знаходить у мапі `nodeToDtoMap` відповідний `void* dto`.
        в. Цей `void* dto` передається в конструктор `ky::Record`, який просто зберігає його у себе. **Жодної модифікації самого DTO на цьому етапі не відбувається.**
        г. **Паралельно**, під час цього ж обходу, `View` встановлює ієрархічні зв'язки між створеними `ky::Record`-ами, як це описано в `RKey_usage.md`.

#### 3.1.2. Керування станом та синхронізація з Protobuf

Роль класів чітко розподілена:

  * **`ky::Record`** інкапсулює бізнес-логіку та актуальний серверний стан даних. Він зберігає непрозорий вказівник `void* dto` на своє `proto`-представлення.
  * **`View`** виступає як оркестратор для повного оновлення представлення.

**Потік роботи такий:**

1.  Клієнт викликає RPC-метод (наприклад, `Reload` або `ShowDetails`), передаючи `rec_id` (RUID) потрібного об'єкта.
2.  gRPC-шар за допомогою глобального реєстру знаходить об'єкт `ky::Recordset` за його `rec_id` в активному View.
3.  На знайденому об'єкті викликається відповідний метод (`reload()` або `showDetails()`).

**Далі є два сценарії, залежно від типу операції:**

  * **Сценарій А: Повертається `Record`/`Recordset` (напр., `Reload`)**

      * Метод `reload()` оновлює внутрішній стан `ky::Record`.
      * Далі `ky::Record` передає себе у зовнішню функцію-серіалізатор (напр., `kyproto::fillDtoFromRecord`), яка створює та повертає фінальне `proto`-повідомлення. **Саме ця функція відповідає за запис RUID, даних та всього стану в DTO.**
      * `View` у цьому процесі **не бере участі**.

  * **Сценарій Б: Повертається `kyproto::View` (напр., `ShowDetails`)**

      * Метод `showDetails()` на об'єкті `ky::Record` ініціює створення **нового `View`**.
      * Він знаходить відповідний `Layout` для детального представлення (наприклад, `nodeForm` для запису з `nodeList`).
      * Через створюється новий екземпляр `ky::View`(new ky::View), який додається в кінець навігаційного ланцюжка і стає активним.
      * Саме `kyproto::View` цього **нового `View`** повертається клієнту.
      * Поточний `View` не змінюється, а стає попереднім у ланцюжку "хлібних крихт".

### 3.2. Операції з даними

`View` виступає як оркестратор для операцій з даними, що містяться в його `Record` та `Recordset` (завантаження, збереження, видалення тощо).

### 3.3. Взаємодія з клієнтом

Взаємодія з клієнтом повністю визначається контрактом `ky.proto`. `View` обробляє RPC-виклики та генерує відповіді (`kyproto::Frame`, `kyproto::Recordset` тощо) для відправки клієнту.

## 4. Взаємодія з фреймворком

  * **Володіння:** Усі екземпляри `View` належать об'єкту `Session`, який управляє їхнім життєвим циклом та навігацією.
  * **Зв'язок з gRPC:** gRPC-шар є "тонким" транслятором, що перенаправляє виклики до методів об'єктів `View`, `Record` та `Recordset`, які є частиною `libkycore`.
  * **Ізоляція `Record`/`Recordset`:** Ці класи нічого не знають про gRPC. Вони лише працюють з даними та структурами Protobuf через хелпери.
  * **Адресація об'єктів:** Клієнт звертається до серверних об'єктів (`View`, `Record` тощо) через `Id32` (RUID), які генеруються за допомогою `RUIDGen`. Ці ID є, по суті, безпечними "замаскованими вказівниками". Сервер використовує глобальний реєстр для співставлення цих ID з реальними вказівниками на об'єкти в пам'яті, що дозволяє їх однозначно ідентифікувати, не розкриваючи клієнту внутрішню архітектуру.