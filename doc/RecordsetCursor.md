### Концепція: Гібридний курсор даних в `ky::Recordset`

Цей документ описує архітектуру курсора всередині C++ класу `ky::Recordset`. Мета архітектури — забезпечити гнучкість та продуктивність, дозволяючи об'єкту `Recordset` працювати у двох різних режимах: швидкому режимі "лише для читання" та повнофункціональному режимі редагування. Вибір режиму залежить від задачі, яку виконує клієнт.

Ця подвійна природа відображена в протоколі взаємодії, де `Recordset` може передавати дані або як полегшений `Dataset`, або як повноцінний набір об'єктів `Records`. Реалізація `ky::Recordset` на сервері повинна підтримувати обидві логіки.

---

### Рівень 1: Курсор завантаження даних (Взаємодія з `SqlDB`)

Цей рівень відповідає за ефективне отримання даних з бази даних і є фундаментом для обох режимів роботи.

* **Механізм:** `ky::Recordset` реалізує 3-кроковий процес завантаження:
    1.  **Отримання загальної кількості:** Виконується запит `SELECT COUNT(*)` для визначення загального розміру набору даних, що необхідно для пагінації.
    2.  **Вибірка ідентифікаторів:** Виконується запит `SELECT id FROM ... LIMIT/OFFSET` для отримання лише унікальних `id` записів для поточної сторінки.
    3.  **Вибірка повних даних:** Виконується запит `SELECT ... FROM ... WHERE id IN (...)` для отримання повних даних лише для потрібних записів. Результат цього запиту зберігається в полі `std::unique_ptr<SqlDB::Result> res;`.

* **Реалізація в `ky::Recordset`:**
    * Поля `filters` , `sorts`  та `pager`  використовуються для динамічної генерації SQL-запитів на кожному з трьох кроків.
    * Поле `res`  зберігає "сирий" результат фінального запиту, готовий для подальшої обробки.

---

### Рівень 2: Курсор представлення даних (Внутрішня логіка `ky::Recordset`)

Це ядро архітектури, що визначає, як `ky::Recordset` обробляє дані, що зберігаються в `res`, і як він управляє станом (активний запис, виділені записи).

#### **Режим 1: "Read-Only" курсор (Емуляція логіки `Dataset`)**

Цей режим використовується, коли клієнту потрібен швидкий доступ до даних без можливості їх редагування. `ky::Recordset` у цьому режимі працює як ефективний ітератор по "сирих" даних.

* **Управління даними:**
    * `ky::Recordset` не створює колекцію повноцінних об'єктів `ky::Record`. Замість цього, він ітерує безпосередньо по результату, що зберігається в `res`.
    * Метод `bool next()`  реалізує цю ітерацію. Він збільшує внутрішній лічильник `int cur_row`  і заповнює поля (`RField`) самого об'єкта `Recordset` даними з поточного рядка `res`. Таким чином, сам `Recordset` діє як єдиний, багаторазово використовуваний "активний" запис.

* **Управління станом:**
    * **Активний рядок:** Стан активного рядка управляється через поле `int32_t active_record_id` , яке є серверною реалізацією(dbid) того, що в протоколі називається `active_row_idx`(page index). Зміна поточного рядка (наприклад, через RPC-виклик `SetCurrentRow` ) просто змінює значення цього поля користуючись мапою.
    * **Виділені рядки:** Для відстеження виділених рядків може використовуватися колекція std::unordered_set<int32_t> selected_record_ids(dbidі). Це відповідає `repeated uint32 selected_row_indices` з протоколу потрапивщих у видиме вікно і транcльованих на page index.

#### **Режим 2: "Editable" курсор (Реалізація логіки `Records`)**
    **Примітка:** На даний момент цей режим є запланованим на майбутнє і ще не реалізований у `rec.h`. Поточна реалізація підтримує лише "Read-Only" режим курсора.    

Цей режим використовується, коли клієнту потрібен повноцінний редагований список, де кожен рядок є самостійним об'єктом.

* **Управління даними:**
    * Після отримання даних в `res`, `ky::Recordset` створює та заповнює колекцію повноцінних об'єктів `ky::Record`. Явна колекція в `rec.h` не показана, треба реалізувати (наприклад, `std::vector<URecord>`).
    * Кожен створений об'єкт `ky::Record` є незалежною сутністю зі своїм набором полів `RField`.
    * Коли клієнт змінює дані, викликається метод `RField::modify()` , який оновлює значення та встановлює прапорець `is_modified = true`. Це дозволяє детально відстежувати зміни на рівні кожного поля кожного запису.

* **Управління станом:**
    * **Активний запис:** Поле `URecord active;`  використовується для зберігання вказівника на той об'єкт `ky::Record` з колекції, який є поточним для редагування (наприклад, у формі деталей).
    * **Виділені записи:** Поле `std::unordered_set<URecord> selected;`  використовується для зберігання вказівників на об'єкти `ky::Record`, які користувач виділив у списку для групових операцій (наприклад, видалення).
    * При збереженні (`Save`) `ky::Recordset` ітерує по своїй колекції об'єктів `Record`, знаходить ті, у яких `is_modified` є `true`, і генерує для них відповідні SQL-запити `UPDATE` або `INSERT`.

### Висновок

Клас `ky::Recordset` реалізує складну, але гнучку концепцію курсора. Він діє як фабрика, що може створювати два типи представлень даних: легковагове, що працює з "сирими" даними через ітератор (`next()`), та повнофункціональне, що оперує колекцією повноцінних об'єктів `Record`. Цей вибір дозволяє системі бути одночасно **швидкою там, де це потрібно**, і **потужною та надійною там, де потрібне редагування**.