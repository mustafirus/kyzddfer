### **Документ: TODO для реалізації ієрархії драйверів `SqlDB`**

**Назва:** TODO: `SqlDB` Database Driver Hierarchy Implementation

**Призначення:** Окреслити завдання з реалізації та інтеграції абстракції доступу до баз даних у структуру проєкту `ky`.

**Ключові архітектурні рішення:**

  * **Базовий клас:** `SqlDB` (5 символів), що є абстрактним інтерфейсом для SQL-баз даних.
  * **Похідні класи:** `SqlDrvPg`, `SqlDrvMy`, `SqlDrvLite`, `SqlDrvOdbc`, що реалізують доступ до конкретних СУБД або технологій.
  * **Життєвий цикл:** У межах одного серверного процесу передбачається використання лише одного екземпляра похідного класу `SqlDB`, що буде керований структурою `Rack`.
  * **Фабрична логіка:** Вибір та створення конкретного драйвера відбуватиметься у методі `Rack::connect`.
  * **Управління залежностями:** Використання попередніх оголошень для мінімізації залежностей компіляції та ізоляції основної логіки `libkycore` від реалізацій драйверів.
  * **Роль `SqlDrvOdbc`:** Використовується як "загальний" драйвер для СУБД, доступних через ODBC, підкреслюючи його специфічну роль у системі.

**Завдання:**

1.  **Створити базовий клас `SqlDB`:**

      * Оголосити `class SqlDB` як абстрактний базовий клас з чисто віртуальними методами для базових операцій (наприклад, `connect()`, `disconnect()`, `execute()`, `query()`) в `src/libkycore/rack.h`.

2.  **Реалізувати похідні класи драйверів `SqlDrv*`:**

      * Для кожного типу СУБД створити окремі файли:
          * `src/libsqldb/sqldrvpg.h` та `src/libsqldb/sqldrvpg.cpp`
          * `src/libsqldb/sqldrvmy.h` та `src/libsqldb/sqldrvmy.cpp`
          * `src/libsqldb/sqldrvlite.h` та `src/libsqldb/sqldrvlite.cpp`
          * `src/libsqldb/sqldrvodbc.h` та `src/libsqldb/sqldrvodbc.cpp`
      * Кожен клас `SqlDrvXxx` повинен успадковувати від `SqlDB` та реалізовувати його чисті віртуальні методи, використовуючи відповідні нативні C/C++ бібліотеки або ODBC API.
      * В конструкторах (або окремих методах) цих драйверів буде виконуватися парсинг отриманого URL connection string (або його частини після схеми) у формат, зрозумілий для їхнього нативного API.

3.  **Інтегрувати систему `SqlDB` в `struct Rack`:**

      * **В `src/libkycore/rack.h`:**
          * Додати **декларацію** `class SqlDB;` перед оголошенням `struct Rack`(зроблено в п.1).
          * Додати член `std::unique_ptr<SqlDB> sqldb;` до `struct Rack`.
          * Оголосити метод `bool connect(sv connection_string);` як публічний член `struct Rack`.
      * **В `src/libsqldb/sqldb.cpp`:**
          * Включити `rack.h`, та **усі заголовки конкретних драйверів** (`sqldrvpg.h`, `sqldrvmy.h` тощо).
          * Реалізувати **метод `bool ky::Rack::connect(sv connection_string)`**.
              * Ця реалізація повинна розпарсити `connection_string` (зокрема, визначити схему `pgsql://`, `mysql://` тощо).
              * Використовуючи `if-else` або `switch` на основі схеми, створити за допомогою `std::make_unique` відповідний об'єкт похідного класу (наприклад, `new SqlDrvPg(connection_string)`) та присвоїти його члену `Rack::sqldb`.


4.  **Налаштувати систему збирання (Build System Configuration):**

      * Переконатися, що `src/libsqldb` компілюється в окрему статичну або динамічну бібліотеку (`libsqldb.a` або `libsqldb.so`).
      * Налаштувати залежності таким чином, щоб `libsqldb` і `libkycore` не залежали один від одого.
      * Забезпечити правильні шляхи включення (include paths) для заголовка    `rack.h`