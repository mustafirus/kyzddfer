## **Архітектурний Документ: Підсистема Доступу до Даних v2.2**

**Мета:** Спроектувати та описати реалізацію надійної, гнучкої та високопродуктивної підсистеми доступу до даних для проєкту `ky`. Цей документ є результатом детального обговорення та слугує посібником для розробки ключових класів: `SqlDB`, `Recordset` та `Record`.

-----

### **1. Архітектура та Принципи Роботи**

В основі підсистеми лежить чіткий розподіл відповідальності між компонентами. Такий підхід дозволяє інкапсулювати складну логіку, оптимізувати продуктивність та забезпечити чистоту коду.

#### **1.1. Загальна Філософія: Сервер — Єдине Джерело Правди**

Ключовим архітектурним рішенням є те, що **сервер завжди є "папіком"**, тобто авторитетним джерелом стану. Клієнт ніколи не формує повний стан (наприклад, `RecordsetParams`) і не надсилає його на сервер. Замість цього, він лише надсилає **Дії** (наприклад, "додати фільтр", "змінити сортування"). Серверна логіка, інкапсульована в класі `View`, отримує цю дію, самостійно модифікує свій внутрішній стан (`RecordsetParams`) і повертає клієнту вже оновлені дані разом з актуальним станом.

**Мотивація:**

  * **Безпека:** Не дозволяє клієнту надсилати довільні, потенційно небезпечні, параметри запиту.
  * **Надійність:** Вся логіка валідації та зміни стану зосереджена в одному місці, що унеможливлює розсинхронізацію.
  * **Чистота архітектури:** Клієнт залишається "тонким", відповідаючи лише за відображення та відправку дій.

#### **1.2. `SqlDB`: Високопродуктивний Менеджер Ресурсів**

`SqlDB` — це не просто виконавець SQL, а "розумний" менеджер ресурсів, що приховує всю складність роботи з конкретною СУБД (для MVP — PostgreSQL).

  * **Кешування Підготовлених Запитів (Prepared Statements):** Щоб уникнути постійного парсингу однакових SQL-запитів, `SqlDB` реалізує внутрішній кеш. Коли `Recordset` потребує виконати запит, він передає `SqlDB` повний текст SQL. `SqlDB` шукає цей текст у своєму кеші:
      * **Знайдено:** Негайно повертає існуючий хендл підготовленого запиту.
      * **Не знайдено:** Створює новий підготовлений запит на сервері PostgreSQL (`PQprepare`), зберігає його хендл у кеші і повертає його.
  * **Оптимізація кешу (спрощений ARC):** Повноцінна реалізація ZFS ARC є складною, але для MVP ми реалізуємо його спрощену, але ефективну версію. Кеш буде розділено на дві частини:
    1.  **"Використано один раз" (Once-used):** Сюди потрапляють всі нові запити.
    2.  **"Використовується часто" (Frequently-used):** Якщо запит з першого списку використовується повторно, він переміщується сюди.
        Коли кеш переповнюється, першими кандидатами на видалення (і `DEALLOCATE` на сервері) є найстаріші записи зі списку "використаних один раз". Це захищає часто використовувані запити від витіснення рідкісними, але новими.
  * **Керування життєвим циклом:** `SqlDB` відповідає за `DEALLOCATE PREPARE`. Виклик `release()` з боку `Recordset` лише повідомляє кешу, що один клієнт закінчив роботу, але не видаляє стейтмент негайно.

#### **1.3. `Recordset`: Динамічний Конструктор Списків**

`Recordset` — це потужний конструктор `SELECT`-запитів.

  * **Генерація SQL:** Він динамічно створює SQL-запити на основі метаданих (`QModel`) та поточного стану `RecordsetParams`. Це дозволяє легко додавати поля, сортування та фільтри.
  * **Взаємодія з кешем `SqlDB`:** `Recordset` зберігає лише непрозорий хендл (`prepared_stmt*`) на підготовлений запит. При будь-якій зміні, що впливає на SQL (фільтри, сортування), він скидає цей хендл, що змушує його при наступному запиті даних згенерувати новий SQL і запросити новий (або існуючий кешований) хендл у `SqlDB`.
  * **Параметри запиту:** Вектор параметрів для запиту формується в `Recordset` з двох джерел:
    1.  Зі значень фільтрів у `RecordsetParams`.
    2.  З контексту, наприклад, `id` батьківського `Record`, на який посилається `RField` через `link`.

#### **1.4. `Record`: Менеджер Атомарних Операцій**

`Record` інкапсулює логіку роботи з одним записом (Create, Read, Update, Delete).

  * **Створення (INSERT):** Процес починається з виклику `Recordset::new`, що створює "порожній" `Record`. Після заповнення полів клієнтом, метод `save()` генерує `INSERT`-запит. **Ключовий момент:** запит використовує клаузу `RETURNING id`, щоб негайно отримати згенерований базою `id` і перетворити "новий" об'єкт на "існуючий".
  * **Оновлення (UPDATE):** `Record` відстежує змінені ("dirty") поля. Метод `save()` для існуючого запису генерує `UPDATE`-запит, що містить **лише змінені поля**, що є важливою оптимізацією.
  * **Принцип "Read-after-Write":** Після кожного `INSERT` або `UPDATE`, `Record` автоматично виконує `SELECT`, щоб перезавантажити свій стан(всі поля не тільки змінені). **Мотивація:** Це гарантує, що стан об'єкта в пам'яті на 100% відповідає стану в базі даних, враховуючи будь-яку логіку на стороні БД (тригери, обчислювані поля тощо).
  * **Транзакційність користувача:** Керування змінами (`reload`, `undo`, `cancel`) забезпечує гнучкість для користувача, дозволяючи відкинути зміни або перезавантажити дані, якщо їх міг змінити інший користувач.

#### **1.5. Ключовий Принцип: Не Ламати Те, Що Працює (Принцип Еволюції)**

В основі всіх технічних рішень лежить фундаментальний принцип: архітектура повинна розвиватися **еволюційно, а не революційно**. Це означає, що будь-які нові компоненти або зміни не повинні руйнувати існуючі, перевірені часом та робочі механізми.

**Мотивація:**

  * **Стабільність:** Система, що розвивається ітераційно, є більш стабільною та передбачуваною.
  * **Збереження знань:** Ми успадковуємо найкращі та найнадійніші практики з попередніх систем, а не винаходимо все з нуля.
  * **Прагматизм над догмою:** Ми робимо свідомий вибір на користь прагматичних рішень, які забезпечують надійність системи в цілому, навіть якщо вони не завжди є "ідеально чистими" з академічної точки зору.
  * **Безперервний рефакторинг:** Цей принцип заохочує постійне покращення внутрішньої структури коду, але з важливою умовою — **без зміни його зовнішньої поведінки**.

Таким чином, будь-який розробник, що працює над цією системою, повинен спочатку зрозуміти, **чому** існуючий код працює саме так, і лише потім вносити зміни, які розширюють, а не руйнують закладений фундамент.

-----

### **2. Завдання для Реалізації та Пропоновані Інтерфейси**

Ось детальний опис завдань та пропонованих інтерфейсів для ключових класів.

#### **2.1. Клас `SqlDB` та реалізація `SqlDrvPg`**

**Інтерфейс `ky::SqlDB`:**

```cpp
// в файлі rack.h
#pragma once
#include <vector>
#include <string>
#include <string_view>
#include <memory>

namespace ky {

class Result; // Попереднє оголошення

class SqlDB {
public:
    // Непрозорий тип для хендла, що приховує деталі реалізації драйвера.
    using PreparedStatementHandle = void;

    virtual ~SqlDB() = default;

    /// Підготувати SQL-запит для виконання.
    /// Повертає хендл на кешований підготовлений стейтмент.
    /// @param sql_query Текст SQL-запиту з плейсхолдерами $1, $2, ...
    virtual PreparedStatementHandle* prepare(sv sql_query) = 0;

    /// Виконати підготовлений запит, що повертає дані (SELECT).
    /// @param stmt Хендл, отриманий від prepare().
    /// @param params Вектор параметрів для запиту.
    /// @return Повертає унікальний вказівник на об'єкт з результатом.
    virtual std::unique_ptr<Result> query_prepared(PreparedStatementHandle* stmt, const std::vector<string>& params) = 0;
    
    /// Виконати запит, що не повертає дані (INSERT, UPDATE, DELETE).
    /// @param sql SQL-запит.
    /// @param params Вектор параметрів.
    /// @return Повертає кількість змінених рядків.
    virtual int execute(sv sql, const std::vector<string>& params) = 0;

    /// Повідомити кешу, що даний "клієнт" (напр., Recordset) більше не використовує цей хендл.
    /// Це НЕ видаляє стейтмент негайно, а лише зменшує лічильник посилань у кеші.
    virtual void release(PreparedStatementHandle* stmt) = 0;

    /// Почати нову транзакцію.
    virtual void beginTransaction() = 0;

    /// Підтвердити поточну транзакцію.
    virtual void commit() = 0;

    /// Відкотити поточну транзакцію.
    virtual void rollback() = 0;
};

} // namespace ky
```

**Завдання для `ky::SqlDrvPg`:**

  * Реалізувати всі віртуальні методи `SqlDB`.
  * Створити приватну структуру для кешу, що містить `std::map<std::string, PreparedStatementInfo>`, де `PreparedStatementInfo` — це структура з хендлом, лічильником посилань та метаданими для ARC.
  * **`prepare()`:** Реалізує логіку "знайти або створити". Використовує `PQprepare`.
  * **`query_prepared()`:** Використовує `PQexecPrepared` для виконання.
  * **`execute()`:** Використовує `PQexecParams` для одноразових запитів.
  * **`release()`:** Зменшує лічильник посилань. Якщо він досягає нуля, переміщує стейтмент у відповідний список (одноразових чи частих) для можливого майбутнього витіснення.

#### **2.2. Клас `Recordset`**

**Пропонований інтерфейс (доповнення до існуючого):**

```cpp
// в файлі rec.h
class Recordset : public Record {
private:
    // скидається при виклику методів setFilter setSort тощо
    SqlDB::PreparedStatementHandle* prepared_stmt_ = nullptr;
public:
    // ... існуючі методи ...

    // Основний метод для завантаження/перезавантаження даних
    void loadData();

    // Методи для зміни стану, що викликають resetPrepared()
    void setFilter(const std::string& field, const std::string& value);
    void setSort(const std::string& field, SortDirection dir);
    void setPage(int page_num);
};
```

**Завдання для `Recordset`:**

  * Реалізувати метод `load()`, який:
    1.  Якщо `prepared_stmt_` є `nullptr`:
        1.  Генерує SQL на основі `RecordsetParams`.
        2.  викликає `db->prepare()` і зберігає в `prepared_stmt_`.
    2.  Виконує запит через `db->query_prepared()` і обробляє результат.
    3.  Кличе `db->release()` щоб звільнити буфер даних db api.

#### **2.3. Клас `Record`**

**Пропонований інтерфейс (доповнення до існуючого):**

```cpp
// в файлі rec.h
class Record {
private:
    std::map<std::string, bool> dirty_fields_;
    bool is_new_ = true;

    // Внутрішні методи для виконання операцій
    void performInsert();
    void performUpdate();
public:
    // ... існуючі методи ...

    // Завантажує дані з БД за id
    void load();

    // Зберігає зміни (викликає INSERT або UPDATE)
    void save();
    
    // Видаляє запис
    void remove();

    // Позначає поле як змінене
    void setField(const std::string& field_name, const std::string& value);
    
    // Відкидає зміни
    void undoChanges();
};
```

**Завдання для `Record`:**

  * **`save()`:** Реалізувати логіку, яка перевіряє `is_new_` і викликає або `performInsert()`, або `performUpdate()`.
  * **`performInsert()`:**
      * Генерує `INSERT ... RETURNING id;`.
      * Виконує через `db->execute()`.
      * Оновлює `id` в `RKey` та встановлює `is_new_ = false;`.
      * Викликає `load()` для синхронізації.
  * **`performUpdate()`:**
      * Генерує `UPDATE SET ... WHERE id = ...;` тільки для полів, що є в `dirty_fields_`.
      * Виконує запит.
      * Викликає `load()` для синхронізації.

-----

### **3. Питання для Майбутніх Етапів**

Для повноцінної реалізації системи необхідно буде вирішити наступні архітектурні питання, розгляд яких наразі відкладено:

1.  **Безпека та Авторизація:** Як реалізувати доступ на рівні записів (RLS), дій та полів на основі ролей користувачів?

      * **На рівні даних:** Хто може бачити ті чи інші записи? Наприклад, менеджер бачить тільки свої проєкти, а директор — усі. Це означає, що **всі `SELECT`-запити**, які генерує `Recordset`, повинні автоматично доповнюватися умовами `WHERE` на основі ролі поточного користувача.
      * **На рівні дій:** Хто може виконувати дії? Чи може звичайний користувач видалити запис, чи це право має тільки адміністратор? Логіка на сервері не повинна навіть генерувати дію "видалити" для клієнта, якщо у користувача немає на неї прав.
      * **На рівні полів:** Чи можуть певні поля бути доступними тільки для читання для одних ролей і для редагування для інших (наприклад, зарплату бачить тільки бухгалтерія)?

2.  **Управління Транзакціями:** Як реалізувати складні бізнес-операції, що вимагають атомарної зміни кількох записів, і який клас має керувати транзакціями? Ми говорили про `save` та `delete` для одного `Record`. Але що, як операція вимагає узгодженої зміни кількох записів у різних таблицях?

      * **Приклад:** Прийняття нового співробітника може вимагати створення запису в таблиці `employees`, створення для нього облікового запису в `users` та запису в `access_logs` — і все це має відбутися **атомарно**. Якщо хоча б один крок не вдався, всі попередні зміни мають бути відкочені.
      * **Питання для архітектури:**
      Хоча інтерфейс для транзакцій (`beginTransaction`, `commit`, `rollback`) додано до `SqlDB`, залишається відкритим питанням розробка стратегії їх використання. Необхідно визначити, який клас (`View`, `Session` чи інший) буде відповідати за керування життєвим циклом транзакцій для складних, багатоетапних бізнес-операцій, що охоплюють кілька об'єктів `Record`.


3.  **Складна Валідація та Обробка Помилок:** Як реалізувати бізнес-правила валідації, що залежать від кількох полів, і як структуровано повідомляти клієнту про конкретні помилки? Ми згадали, що `Record` валідує дані. Давайте деталізуємо, як саме.

      * **Джерело правил:** `ky-format.md` згадує атрибут `validate_re`, що є чудовим початком для простих перевірок.
      * **Складні правила:** А як щодо складних бізнес-правил? Наприклад, "дата завершення проєкту не може бути раніше дати його початку" або "загальна сума замовлення не може перевищувати кредитний ліміт клієнта". Ці правила вимагають доступу до кількох полів одночасно.
      * **Зворотній зв'язок:** Як сервер повідомить клієнту про **конкретну** помилку? Не просто "Помилка збереження", а "Поле 'email' має невірний формат" або "Цей логін вже зайнятий".
      * **Пропозиція:** `Record::save()` повинен повертати не просто успіх/невдачу, а структурований об'єкт з відповіддю, який може містити список помилок валідації по кожному полю.

4.  **Конфігурація:** Який механізм використовувати для завантаження конфігураційних даних (рядки підключення, порти, логування) із зовнішніх джерел?

      * Звідки програма знає, до якої бази даних підключатися (для розробки, тестування, продакшену)?

5.  **Проектування Механізму Фільтрації:** Функціонал простої фільтрації (`field = value`) є недостатнім. Необхідно створити окремий архітектурний документ, що опише розширену структуру `RecordsetParams::Filter` для підтримки складних умов (`>`,`<`, `LIKE`, `IN`, `IS NULL` тощо) та механізм безпечної генерації відповідних `WHERE`-клауз.
